mean(sA)
mean(sB)
nfit <- lm(count ~ spray - 1, InsectSprays)
summary(nfit)$coef
spray2 <- relevel(InsectSprays$spray, "C")
fit2 <- lm(count ~ spray, InsectSprays)
fit2 <- lm(count ~ spray2, InsectSprays)
summary(fit2)$coef
mean(sC)
(fit$coef[3]-fit$coef[2])/1.6011
(fit$coef[2]-fit$coef[3])/1.6011
dim(hunger)
948
names(hunger)
fit <- lm(Numeric ~ Year, hunger)
summary(fit)
summary(fit)$coef
lmF <- lm(Numeric ~ Year, hunger[hunger$Sex=="Female"])
lmF <- lm(Numeric ~ Year, hunger[,hunger$Sex=="Female"])
lmF <- lm(Numeric ~ Year, subset(hunger,hunger$Sex=="Female")
)
lmF <- lm(Numeric[Sex=="Female"] ~ Year[Sex=="Female"],hunger)
lmM <- lm(Numeric[Sex=="Male"] ~ Year[Sex=="Male"],hunger)
lmBoth <- lm(Numeric ~ Year + Sex, hunger)
summary(lmBoth)
lmInter <- lm(Numeric ~ Year + Sex + Sex*Year, hunger)
summary(lmInter)
fit <- lm(y ~ x, out2)
plot(fit, which=1)
fitno <- lm(y ~ x, out2[-1, ])
plot(fitno, which=1)
coef(fit) - coef(fitno)
head(dfbeta(fit))
resno <- out2[1, "y"] - predict(fitno, out2[1,])
1-resid(fit)[1]/resno
head(hatvalues(fit))
sigma <- sqrt(deviance(fit)/summary(fitno))
sigma <- sqrt(deviance(fit)/1)
sigma <- sqrt(deviance(fit)/df.residual(fit))
rstd <- sigma / sigma*sqrt(1-hatvalues(fit))
rstd <- resid(fit) / sigma*sqrt(1-hatvalues(fit))
rstd <- resid(fit) / (sigma*sqrt(1-hatvalues(fit)))
head(cbind(rstd, rstandard(fit)))
plot(fit, which=3)
plot(fit, which=2)
sigma1 <- sqrt(deviance(fitno)/df.residual(fitno))
resid(fit)[1] / (sigma1*sqrt(1-hatvalues(fit)[1]))
head(rstudent(fit))
dy <- predict(fitno, out2) - predict(fit, out2)
dy / (2*sigma^2)
dy^2 / (2*sigma^2)
(dy^2) / (2*sigma^2)
sum(dy^2) / (2*sigma^2)
plot(fit, which=5)
swirl()
library(swirl)
swirl()
rpg1()
rgp1 <- function(){
print("Processing. Please wait.")
# number of samples per simulation
n <- 100
# number of simulations
nosim <- 1000
# set seed for reproducability
set.seed(4321)
# Point A
x1 <- rnorm(n)
x2 <- rnorm(n)
x3 <- rnorm(n)
# Point B
betas <- sapply(1 : nosim, function(i)makelms(x1, x2, x3))
round(apply(betas, 1, var), 5)
}
rgp1()
rgp2()
head(swiss)
mdl <- lm(Fertility ~ ., swiss)
vif(mdl)
mdl2 <- lm(Fertility ~ Agriculture + Education + Catholic + Infant.Mortality, swiss)
vif(mdl2)
x1c <- simbias()
apply(x1c, 1, mean)
fit <- lm(Fertility ~ Agriculture, swiss)
fit1 <- lm(Fertility ~ Agriculture, swiss)
fit3 <- lm(Fertility ~ Agriculture + Examination + Education, swiss)
anova(fit1, fit3)
deviance(fit3)
d <- deviance(fit3)/43
n <- deviance(fit1)-deviance(fit3)
n <- (deviance(fit1)-deviance(fit3))/2
n/d
pf(n/d, 2, 43, lower.tail=FALSE)
shapiro.test(fit3$residuals)
anova(fit1, fit3, fit5, fit6)
View(ravenData)
mdl <- glm(ravenWinNum ~ ravenScore, family="binomial", ravenData)
loods<-predict(mdl, data.frame(ravenScore=c(0, 3, 6))
)
loods<-predict(mdl, data.frame(ravenScore=c(0, 3, 6)))
loods <- predict(mdl, data.frame(ravenScore=c(0, 3, 6)))
lodds <- predict(mdl, data.frame(ravenScore=c(0, 3, 6)))
exp(lodds)/(1+exp(lodds))
summary(mdl)
exp(confint(mdl))
anova(mdl)
qchisq(0.95, 1)
var(rpois(1000, 50))
nxt()
head(hits)
class(hits[,'date'])
as.integer(head(hits[,'date']))
mdl <- glm(visits ~ date, poisson, hits)
summary(mdl)
exp(confint(mdl, 'date'))
which.max(hits[,'visits']
)
hits[704,]
lambda <- mdl$fitted.values[704]
qpois(.95,lambda)
mdl2 <- glm(visits ~ date, offset=log(visits+1), poisson, hits)
mdl2 <- glm(formula = simplystats ~ date, family = poisson, data = hits, offset = log(visits + 1))
qpois(.95,mdl2$fitted.values[704])
1 * 0.1 + 2 * 0.2 + 3 * 0.3 + 4 * 0.4
1/0.2
(0.3*0.75)/(0.3*0.75)+(0.7*0.25)
(0.3*0.75)/(0.3*0.75)+((1-.52)*0.25)
?t.test
1100 + qnorm(0.95) * 30/sqrt(9)
1100 + qnorm(0.95, df=8) * 30/sqrt(9)
1100 + qt(0.95, df=8) * 30/sqrt(9)
1100 - qt(0.95, df=8) * 30/sqrt(9)
round(qt(.975, df = 8) * 1 / sqrt(n), 2) = -2
qt(.95, df = 8)
1.859548 * x / 3 + (-2)
2 * 3 -1.859548
1.859548 * x / 3 + (-2)
n1 <- n2 <- 20
x1 <- 3
x1 <- 3 #new system
x2 <- 5 #old systeme
s1 <- 0.6
s2 <- 0.68
spsq <- ( (n1 - 1) * s1^2 + (n2 - 1) * s2^2) / (n1 + n2 - 2)
spsq
qnorm(0.95) * c(1,-1) * s1/sqrt(n1) + x1
qnorm(0.95) * c(1,-1) * s2/sqrt(n2) + x2
3.22068 - 5.250104
3.22068 - 2.77932
pow
power
?power
2^2
(x2-x1) + c(-1.1) * qt(0.95, df=38) * (1/n1 + 1/n2)^1/2 * spsq
(x2-x1) + (c(-1.1) * qt(0.95, df=38) * (1/n1 + 1/n2)^1/2 * spsq)
(x2-x1) + (c(-1,1) * qt(0.95, df=38) * (1/n1 + 1/n2)^1/2 * spsq)
(x2-x1) + (c(-1,1) * qt(0.975, df=38) * (1/n1 + 1/n2)^1/2 * spsq)
(x1-x2) + (c(-1,1) * qt(0.975, df=38) * (1/n1 + 1/n2)^1/2 * spsq)
spsq <- ( (n1 - 1) * s1^2 + (n2 - 1) * s2^2) / (n1 + n2 - 2)
spsq <- sqrt(( (n1 - 1) * s1^2 + (n2 - 1) * s2^2) / (n1 + n2 - 2))
(x1-x2) + (c(-1,1) * qt(0.975, df=38) * (1/n1 + 1/n2)^1/2 * spsq)
(x1-x2) + (c(-1,1) * qt(0.975, df=18) * (1/n1 + 1/n2)^1/2 * spsq)
x <- c(140, 138, 150, 148, 135)
y <- c(132,135,151,146,130)
t.test(x,y)
t.test(y,x)
?t.test
t.test(y,x, alternative="less")
t.test(x,y, alternative="less")
t.test(x,y, alternative="greater")
t.test(y,x alternative="greater")
t.test(y,x, alternative="greater")
t.test(x,y, alternative="two-sided")
t.test(x,y, alternative="two.sided")
t.test(y, alternative="two.sided")
t.test(x,y, alternative="two.sided")
t.test(x,y, alternative="two.sided")$p-value
t.test(x,y, alternative="two.sided")$p
t.test(x,y, alternative="two.sided")
install.packages("shiny")
install.packages("rCharts")
install.packages("googleVis")
install.packages('devtools')
install.packages('devtools')
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
install.packages("rtools")
devtools::install_github('rstudio/shinyapps')
shinyapps::setAccountInfo(name='superpri',
token='24084D393D0E0E0712B7720F734B2085',
secret='<SECRET>')
shinyapps::setAccountInfo(name='superpri',
token='24084D393D0E0E0712B7720F734B2085',
secret='<SECRET>')
shinyapps::setAccountInfo(name='superpri', token='24084D393D0E0E0712B7720F734B2085', secret='CIggj89REoF8U3VRKumqyYZE6iZaMp2li3SnoHYk')
library(shinyapps)
shinyapps::deployApp('path/to/your/app')
library(manipulate)
myPlot <- function(s) {
plot(cars$dist - mean(cars$dist), cars$speed - mean(cars$speed))
abline(0, s)
}
myplot
myPlot
plot(myPlot)
manipulate(myPlot(s), x.s = slider(0, 2, step = 0.1))
manipulate(myPlot(s), s = slider(0, 2, step = 0.1))
manipulate(myPlot(s), slider = x(0, 2, step = 0.1))
manipulate(myPlot, s = slider(0, 2, step = 0.1))
manipulate(myPlot, s = slider(0, 2, step = 0.1))
library(devtools)
install_github('slidify','ramnathv')
install_github('slidify','ramnathv/slidify')
install_github('slidify','slidify')
install_github('ramnathv/slidify')
install_github('ramnathv/slidifyLibraries')
library(AppliedPredictiveModeling)
library(caret)
data(AlzheimerDisease)
install.packages('caret")')
install.packages('caret')
library(AppliedPredictiveModeling)
library(caret)
data(AlzheimerDisease)
library(AppliedPredictiveModeling)
library(caret)
data(AlzheimerDisease)
install.packages('AppliedPredictiveModeling')
library(AppliedPredictiveModeling)
library(caret)
data(AlzheimerDisease)
?createDataPartition
adData = data.frame(diagnosis,predictors)
trainIndex = createDataPartition(diagnosis, p = 0.50,list=FALSE)
trainIndex
length(trainIndex)
typeof(trainIndex)
str
(trainIndex)
summary(trainIndex)
trainIndex = createDataPartition(diagnosis, p = 0.50)
summary(trainIndex)
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(975)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
summary(training)
qq <- qplot(CompressiveStrength,inTrain,colour=Cement, data=training)
qq
qq <- qplot(CompressiveStrength,inTrain,colour=BlastFurnaceSlag, data=training)
qq
qq <- qplot(CompressiveStrength,inTrain,colour=FlyAsh, data=training)
qq
cutCement <- cut2(training$Cement)
install.packages('Hmisc')
cutCement <- cut2(training$Cement)
library(Hmiscc)
library(Hmisc)
cutCement <- cut2(training$Cement)
qq <- qplot(cutCement,inTrain,colour=Cement, data=training)
qq
qqCement <- qplot(cutCement,inTrain,colour=Cement, data=training)
summary(training)
cutBlastFurnaceSlag <- cut2(training$BlastFurnaceSlag)
qqBlastFurnaceSlag <- qplot(cutBlastFurnaceSlag,inTrain,colour=BlastFurnaceSlag, data=training)
cutFlyAsh <- cut2(training$FlyAsh)
qqFlyAsh <- qplot(cutFlyAsh,inTrain,colour=FlyAsh, data=training)
cutWater <- cut2(training$Water)
qqWater <- qplot(cutWater,inTrain,colour=v, data=training)
cutSuperplasticizer <- cut2(training$Superplasticizer)
qqSuperplasticizer <- qplot(cutSuperplasticizer,inTrain,colour=v, data=training)
cutCoarseAggregate <- cut2(training$CoarseAggregate)
qqCoarseAggregate <- qplot(cutCoarseAggregate,inTrain,colour=v, data=training)
cutFineAggregate <- cut2(training$FineAggregate)
qqFineAggregate <- qplot(cutFineAggregate,inTrain,colour=v, data=training)
cutAge <- cut2(training$Age)
qqAge <- qplot(cutAge,inTrain,colour=v, data=training)
cutCompressiveStrength <- cut2(training$CompressiveStrength)
qqAge <- qplot(cutAge,inTrain,colour=Age, data=training)
qqCompressiveStrength <- qplot(cutCompressiveStrength,inTrain,colour=CompressiveStrength, data=training)
grid.arrange(qqCement, qqBlastFurnaceSlag, qqFlyAsh, qqWater, qqSuperplasticizer, qqCoarseAggregate, qqFineAggregate, qqAge, qqCompressiveStrength, ncol=5, nrow=2)
??grid.arrange
library(ggplot2)
library(gridExtra)
library(ggplot2)
install.packages(gridExtra)
library(ggplot2)
install.packages('gridExtra')
grid.arrange(qqCement, qqBlastFurnaceSlag, qqFlyAsh, qqWater, qqSuperplasticizer, qqCoarseAggregate, qqFineAggregate, qqAge, qqCompressiveStrength, ncol=5, nrow=2)
library('gridExtra')
grid.arrange(qqCement, qqBlastFurnaceSlag, qqFlyAsh, qqWater, qqSuperplasticizer, qqCoarseAggregate, qqFineAggregate, qqAge, qqCompressiveStrength, ncol=5, nrow=2)
qqWater <- qplot(cutWater,inTrain,colour=Water, data=training)
qqSuperplasticizer <- qplot(cutSuperplasticizer,inTrain,colour=Superplasticizer, data=training)
qqCoarseAggregate <- qplot(cutCoarseAggregate,inTrain,colour=CoarseAggregate, data=training)
qqFineAggregate <- qplot(cutFineAggregate,inTrain,colour=FineAggregate, data=training)
grid.arrange(qqCement, qqBlastFurnaceSlag, qqFlyAsh, qqWater, qqSuperplasticizer, qqCoarseAggregate, qqFineAggregate, qqAge, qqCompressiveStrength, ncol=5, nrow=2)
hist(training$Superplasticizer)
curve(dnorm(x, mean=mean(training$Superplasticizer), sd=sd(training$Superplasticizer)), add=TRUE, col="darkblue", lwd=2)
hist(log(training$Superplasticizer))
curve(dnorm(x, mean=mean(log(training$Superplasticizer)), sd=sd(log(training$Superplasticizer)), add=TRUE, col="darkblue", lwd=2)
)
curve(dnorm(x, mean=mean(log(training$Superplasticizer)), sd=sd(log(training$Superplasticizer))), add=TRUE, col="darkblue", lwd=2)
curve(dnorm(x, mean=mean(log(training$Superplasticizer)), sd=sd(log(training$Superplasticizer))), add=TRUE, col="darkblue", lwd=2)
hist(training$Superplasticizer)
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
?predict
sumarry(training)
summary(training)
summary(training)
training
names(training)
names(training)["*IL*"]
names(training)[58:69]
x <- training[,58:69]
prComp <- prcomp(x)
prComp
summary(x)
prComp$rotation
?predict
?prcomp
prComp <- preProcess(training[,58:69], method="pca", thresh=0.8)
prComp$rotation
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
x <- training[,58:69]
prComp80 <- preProcess(x, method="pca", thresh=0.8)
prComp <- preProcess(x, method="pca")
modelFit80 <- train(training[,58:69], method="glm",data=prcomp80)
modelFit80 <- train(training[,58:69]~. , method="glm",data=prcomp80)
modelFit80 <- train(training[,58:69]-. , method="glm",data=prcomp80)
modelFit80 <- train(training[,58:69] ~ . , method="glm",data=prcomp80)
modelFit80 <- train(training[,58:69] ~ . , method="glm",data=prComp80)
modelFit80 <- train(diagnosis ~ . , method="glm",data=prComp80)
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
predictorsIL <- predictors[,58:69]
x <- df(diagnosis,predictorsIL)
x <- data.frame(diagnosis,predictorsIL)
inTrain = createDataPartition(x$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
modelFit <- train(diagnosis ~ ., method = "glm", data = training)
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
predictorsIL <- predictors[,58:69]
x <- data.frame(diagnosis,predictorsIL)
inTrain = createDataPartition(x$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
modelFit <- train(diagnosis ~ ., method = "glm", data = training)
install.packages('e1071')
library(caret)
library(AppliedPredictiveModeling)
set.seed(3433)
data(AlzheimerDisease)
adData = data.frame(diagnosis,predictors)
inTrain = createDataPartition(adData$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
predictorsIL <- predictors[,58:69]
x <- data.frame(diagnosis,predictorsIL)
inTrain = createDataPartition(x$diagnosis, p = 3/4)[[1]]
training = adData[ inTrain,]
testing = adData[-inTrain,]
modelFit <- train(diagnosis ~ ., method = "glm", data = training)
confusionMatrix(modelFit)
print(confusionMatrix(modelFit))
predictions <- predict(modelFit, newdata = testing)
confusionMatrix(predictions, testing$diagnosis)
xx <- preProcess(training[,58:69], method="pca", thresh=0.8)
modelFit <- train(training$diagnosis ~ ., method = "glm", preProcess = "pca",
data = training, trControl = trainControl(preProcOptions = list(thresh = 0.8)))
confusionMatrix(testing$diagnosis, predict(modelFit, testing))
set.seed(3433)
## grep the predictors starting with 'IL'
IL_str <- grep("^IL", colnames(training), value = TRUE)
## make a subset of these predictors
predictors_IL <- predictors[, IL_str]
df <- data.frame(diagnosis, predictors_IL)
inTrain = createDataPartition(df$diagnosis, p = 3/4)[[1]]
training = df[inTrain, ]
testing = df[-inTrain, ]
## train the data using the first method
modelFit <- train(diagnosis ~ ., method = "glm", data = training)
predictions <- predict(modelFit, newdata = testing)
## get the confustion matrix for the first method
C1 <- confusionMatrix(predictions, testing$diagnosis)
print(C1)
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(975)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[inTrain, ]
testing = mixtures[-inTrain, ]
names <- colnames(concrete)
names <- names[-length(names)]
featurePlot(x = training[, names], y = training$CompressiveStrength, plot = "pairs")
?seq_along
index <- seq_along(1:nrow(training))
ggplot(data = training, aes(x = index, y = CompressiveStrength)) + geom_point() +
theme_bw()
cutCS <- cut2(training$CompressiveStrength, g = 4)
??cut2
library('Hmisc')
cutCS <- cut2(training$CompressiveStrength, g = 4)
ggplot(data = training, aes(y = index, x = cutCS)) + geom_boxplot() + geom_jitter(col = "blue") +
theme_bw()
featurePlot(x = training[, names], y = cutCS, plot = "box")
library(AppliedPredictiveModeling)
data(concrete)
library(caret)
set.seed(975)
inTrain = createDataPartition(mixtures$CompressiveStrength, p = 3/4)[[1]]
training = mixtures[ inTrain,]
testing = mixtures[-inTrain,]
hist(training$Superplasticizer)
log(0)
install.packages("shiny")
libray(shiny)
library(shiny)
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
l <- list("Cylinders" = "cyl",
"Transmission" = "am",
"Gears" = "gear")
classof(l)
typeof(l)
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
l <- list("oh plz choose me"= "",
"Cylinders" = "cyl",
"Transmission" = "am",
"Gears" = "gear")
l[-"Cylinders"]
l[1]
l[1,1]
l[2]
l[-1]
l["Cylinder"]
l
l[l$Cylinders]
l[-l$Cylinders]
index(l)
index(l,"Cylinders")
which("Cylinders" == l)[[1]]
x <- "cyl"
l$oh plz choose me
l$Cylinders
which(x == l)[[1]]
l[-which(x == l)[[1]]]
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts')
shiny::runApp('coursera/developingDataProducts/developingDataProductsCourseProject')
shiny::runApp('coursera/developingDataProducts/developingDataProductsCourseProject')
l[which(x == l)[[1]]]
l[which(x == l)[[1]]]$1
l[which(x == l)[[1]]]
l[which(x == l)[[1]],]
l[which(x == l)[[1]]]
l[which(x == l)[[1]]])
l[which(x == l)[[1]])]
l[which(x == l)[[1]]]
typeof(l[which(x == l)[[1]]])
l[which(x == l)[[1]]]$1
l[which(x == l)[[1]]]
shiny::runApp('coursera/developingDataProducts/developingDataProductsCourseProject')
shiny::runApp()
